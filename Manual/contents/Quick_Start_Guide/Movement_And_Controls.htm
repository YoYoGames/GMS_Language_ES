<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Movimiento y controles</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code and DnD to show people how to move things around within a game." />
  <meta name="rh-index-keywords" content="Quick Start - Movement And Controls" />
  <meta name="search-keywords" content="movement,controls" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Movimiento y controles</h1>
  <p>En la <a href="Drawing.htm">sección</a> anterior de esta Guía de Inicio Rápido se dieron algunos ejemplos para dibujar cosas en la pantalla, pero dibujar cosas no sirve de mucho si no puedes también moverlas... así que en esta sección te daremos
    algunos ejemplos de movimiento para tus objetos, así como algunos esquemas de control básicos para diferentes tipos de juegos. Todos los ejemplos se dan usando <span class="notranslate">Drag and Drop™</span><span class="notranslate">(DnD™</span>) así como el <span class="notranslate">Lenguaje de GameMaker</span><span class="notranslate">(GML</span>), así que puedes usar el que te sientas más
    con el que te sientas más cómodo. Ten en cuenta que no vamos a explicar las cosas con demasiada profundidad aquí, ya que queremos que empieces a hacer cosas lo más rápido posible, así que te animamos a explorar cualquier enlace a medida que avanzas y a utilizar la función de &quot;búsqueda&quot;
    del manual para buscar información adicional sobre cualquier cosa de la que no estés seguro.</p>
  <p>Antes de seguir adelante, es posible que desee hacer un nuevo proyecto (ya sea <span class="notranslate">GML</span> o <span class="notranslate">DnD ™</span>) de la <a href="../Introduction/The_Start_Page.htm">página de inicio</a>, y añadir (o crear) algunos sprites, así como un objeto o dos - como vamos a dar algunos
    código que puedes probar usando estos - y asegúrate de que el proyecto tiene una habitación para colocar instancias. No te preocupes demasiado por el aspecto de los sprites que hagas, ya que incluso un simple cuadrado blanco servirá, y una vez que tengas todo listo
    puedes empezar a trabajar en los ejemplos que se indican a continuación.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Muévete hacia el ratón</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">Una de las formas más sencillas de hacer que un objeto se mueva e interactúe con el jugador es utilizar el ratón, y en este ejemplo te mostraremos cómo utilizar un código básico para hacer que un objeto se mueva hacia donde el usuario haya pulsado el botón izquierdo del ratón
      <img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png"> .</p>
    <p class="dropspot">Para empezar, abre un objeto, asígnale un sprite, y luego dale un <strong>evento global de Mouse Down izquierdo</strong>:</p>
    <p class="dropspot"><img alt="Adding The Mouse Left Button Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_GlobalLMBDownEvent.png" /></p>
    <p class="dropspot">Usamos los eventos <strong>globales </strong>del ratón porque detectan un clic en cualquier parte de la habitación, mientras que los eventos regulares del ratón sólo detectarán un clic si el ratón realmente hace clic dentro del <a class="glossterm" data-glossterm="bounding box" href="#">cuadro delimitador de</a> la instancia. En este evento queremos añadir este <span class="notranslate">DnD™</span>o <span class="notranslate">GML</span>:</p>
    <p class="dropspot"><img alt="DnD To Move Instance Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_1.png" /></p>
    <p class="code">mover_hacia_el_punto(mouse_x, mouse_y, 2);</p>
    <p class="dropspot">Aquí le estamos diciendo a la instancia que se mueva hacia una posición en la pantalla, en este caso la posición &quot;<span class="inline">mouse_x</span>&quot; y &quot;<span class="inline">mouse_y</span>&quot; (&quot;<span class="inline">mouse_x</span>&quot;
      y &quot;<span class="inline">mouse_y</span>&quot; son <strong>variables </strong> incorporadas <a class="glossterm" data-glossterm="variable" href="#">que</a>siempre mantienen la posición actual del cursor del ratón). El <span class="notranslate">DnD™</span>
      hace esto estableciendo las variables &quot;<span class="inline">direction</span>&quot; y &quot; <span class="inline">speed</span>&quot; <a href="../GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/Instance_Variables.htm"><strong>Variables de la instancia</strong></a>,
      mientras que el <span class="notranslate">GML</span> lo hace mediante la función <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/move_towards_point.htm"><span class="inline">move_towards_point()</span></a> (esto también establece las variables <span class="inline">speed </span>y
      <span class="inline">direction </span> , sólo que en una función única y fácil de usar).</p>
    <p class="dropspot">Coloca una instancia de este objeto en una habitación y pulsa el botón Play <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png">, luego haz clic en <img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png"> alrededor de
      la habitación para que la instancia se mueva hacia el ratón:</p>
    <p class="dropspot"><img alt="Animation Of Instance Moving Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_1.gif">¡Genial! La instancia del objeto ahora se mueve hacia donde hiciste clic, y si mantienes presionado el botón, la instancia
      se mantendrá siguiendo el cursor del ratón. Sin embargo, hay un problema... Después de hacer clic una vez y soltarlo, la instancia seguirá moviéndose y finalmente saldrá de la habitación. Hay varias formas de arreglar esto, y la que elijas
      dependerá de lo que quieras hacer, pero la solución más fácil por ahora es simplemente añadir un evento <strong>global de liberación</strong> del botón del ratón, así que añádelo ahora al objeto y dale este código:</p>
    <p class="dropspot"><img alt="DnD To Set The Instance Speed" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_2.png" /></p>
    <p class="code">velocidad = 0;</p>
    <p class="dropspot">Con esto, la instancia sólo seguirá el cursor del ratón mientras se mantenga pulsado el botón del ratón, y cuando sueltes el botón dejará de moverse. Pulsa Play <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png"> y pruébalo ahora.</p>
    <p class="dropspot">Antes de dejar este ejemplo, hay una última cuestión que debemos resolver... Si haces clic y <em>mantienes </em>el botón del ratón, pero no mueves el cursor, entonces la instancia se moverá hacia el cursor y luego &quot;vibrará&quot; alrededor de él.
      Esto se debe a que la instancia se está moviendo más rápido que 1 píxel a la vez y por lo tanto &quot;sobre-dispara&quot; la posición y luego trata de moverse hacia atrás, y luego sobre-dispara de nuevo, etc ... (hacer la velocidad de movimiento 5 o algo así para ver el problema si
      no es inmediatamente obvio).</p>
    <p class="dropspot"><img alt="Animation Showing Instance Vibrating" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_2.gif">Para solucionar esto tenemos que añadir un <strong>Evento de Paso</strong> al objeto con este código:</p>
    <p class="dropspot"><img alt="DnD Actions For The Step Event" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_3.png" /></p>
    <p class="code">var _dist = point_distance(x, y, mouse_x, mouse_y);<br> if _dist &lt;= speed<br> {<br> speed = 0;<br> }</p>
    <p class="dropspot">Aquí sólo comprobamos la distancia de la instancia a la posición del ratón, y si es igual o menor que la velocidad actual, ponemos la velocidad a 0. Esto hace que la instancia se detenga cuando está lo suficientemente cerca de la posición del ratón, y no tenemos
      no se produce ese desagradable problema de &quot;vibración&quot;.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">Movimiento de 4 y 8 direcciones con el teclado</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot"><a href="What_Is_Programming_.htm">Justo al principio de esta</a> guía, te mostramos el siguiente código <span class="notranslate">DnD™</span>y <span class="notranslate">GML</span> para mover una instancia a la derecha dos píxeles en cada paso del juego:</p>
    <p class="dropspot"><img alt="DnD Example" class="center" src="../assets/Images/QS_Guide/QS_DnD_Example.png" /></p>
    <p class="code">x = x + 2;</p>
    <p class="dropspot">Este tipo de movimiento se llama movimiento <strong>posicional </strong>, ya que esencialmente estamos recogiendo la instancia y colocándola de nuevo en una nueva posición cada vez que se ejecuta el código. Lo que vamos a hacer en este ejemplo es mostrar cómo
      utilizar este tipo de movimiento para mover una instancia en 4 direcciones: arriba, abajo, izquierda y derecha.</p>
    <p class="dropspot">Para empezar, abre un objeto y asígnale un sprite. Ahora, podríamos añadir varios eventos de <strong>teclado</strong> en este punto, y en cada uno hacer que la instancia se mueva en la dirección deseada, sin embargo, sólo queremos que el jugador sea capaz de moverse
      Sin embargo, sólo queremos que el jugador pueda moverse en una dirección a la vez y hacer esto con sólo los eventos de teclado es un poco más complicado que hacerlo usando código. En su lugar, utilizaremos el evento de paso <strong>-que</strong> debes añadir ahora al objeto- con lo siguiente
     <span class="notranslate">DnD™</span>o <span class="notranslate">GML</span> para usar las Teclas de Flecha para moverse:</p>
    <p class="dropspot"><img alt="DnD Step Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_1.png" /></p>
    <p class="code">if keyboard_check(vk_left)<br> {<br> x = x - 2;<br> } <br> else if keyboard_check(vk_right)<br> {<br> x = x + 2;<br> } <br> else if keyboard_check(vk_up)<br> {<br> y = y - 2;<br> } <br> else if keyboard_check(vk_down)<br> {<br> y = y - 2;<br> }</p>
    <p class="dropspot">Estamos utilizando una estructura &quot; <span class="inline">if... else if... else if...</span>&quot; para asegurar que la instancia sólo se moverá en una dirección a la vez, por lo que la instancia sólo debe ser capaz de moverse hacia arriba, abajo, izquierda o derecha, pero no
      en diagonal. Coloca una instancia del objeto en una habitación y pulsa el botón <strong>Play </strong> <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png"> para probarlo ahora. Si todo ha ido correctamente, deberías tener algo
      como esto:</p>
    <p class="dropspot"><img alt="Animation Showing 4-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_1.gif" /></p>
    <p class="dropspot">Podemos modificar este código para convertir el movimiento de 4 direcciones en movimiento de 8 direcciones fácilmente también... simplemente elimina los comandos &quot; <span class="inline">else</span>&quot; de los bloques de código para que todo se vea así:</p>
    <p class="dropspot"><img alt="DnD Step Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_2.png" /></p>
    <p class="code">if keyboard_check(vk_left)<br> {<br> x = x - 2;<br> } <br> if keyboard_check(vk_right)<br> {<br> x = x + 2;<br> } <br> if keyboard_check(vk_up)<br> {<br> y = y - 2;<br> } <br> if keyboard_check(vk_down)<br> {<br> y = y - 2;<br> }</p>
    <p class="dropspot">Ahora, al pulsar el botón de <strong>reproducción </strong> <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png"> se verá algo así:</p>
    <p class="dropspot"><img alt="Animation Showing 8-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_2.gif" /></p>
    <p class="dropspot">Una última cosa que vale la pena señalar para los usuarios que codifican con GML.. <span class="notranslate">.</span> Cuando se utiliza el <span class="notranslate">DnD™</span>se puede seleccionar la tecla del teclado que se quiere utilizar de una lista desplegable, pero con <span class="notranslate">GML</span> no es tan sencillo. Hay una serie de <a href="../GameMaker_Language/GML_Reference/Game_Input/Keyboard_Input/Keyboard_Input.htm">constantes de teclado</a> que
      puede utilizar - como las constantes de las teclas de flecha que se muestran en el código anterior - pero <em>no </em>hay constantes para las teclas alfanuméricas. Éstas se manejan de forma ligeramente diferente, y requieren el uso de la función <a href="../GameMaker_Language/GML_Reference/Strings/ord.htm"><span class="inline">ord()</span></a>.
      El código de abajo muestra cómo funcionaría esto usando WASD en lugar de las teclas de flecha:</p>
    <p class="code">if keyboard_check(ord(&quot;A&quot;))<br> {<br> x = x - 2;<br> } <br> if keyboard_check(ord(&quot;D&quot;))<br> {<br> x = x + 2;<br> } <br> if keyboard_check(ord(&quot;W&quot;))<br> {<br> y = y - 2;<br> } <br> if keyboard_check(ord(&quot;S&quot;))<br> {<br> y = y - 2;<br> }</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Movimiento del Gamepad</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Ya hemos hablado del movimiento del ratón y del teclado, así que es hora de hablar del <strong>movimiento </strong>del gamepad. Ahora, no cubriremos el d-pad, ya que realmente funciona igual que el teclado (simplemente cambia las funciones del teclado
      en el ejemplo anterior por <a href="../GameMaker_Language/GML_Reference/Game_Input/GamePad_Input/gamepad_button_check.htm"><span class="inline">gamepad_button_check()</span></a> o <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Gamepad/If_Gamepad_Button_Down.htm">si el botón del Gamepad está abajo</a>),
      así que en este ejemplo veremos el uso del stick analógico para el movimiento.</p>
    <p class="dropspot">Para empezar, tenemos que detectar el gamepad que se está utilizando. Los gamepads tienen un valor de ID de 0 a 11, así que usaremos un bucle &quot; <span class="inline">for</span>&quot; para detectar el ID de cualquier gamepad conectado y almacenar este valor de ID en una variable
      para su uso futuro. Como sólo queremos detectar el primer gamepad que se conecta y no todos, utilizaremos el comando &quot; <span class="inline">break</span>&quot; después de detectar un gamepad para que se &quot;rompa&quot; el bucle (por
      ejemplo, si el primer gamepad conectado es el ID 4, entonces el bucle sólo se ejecutará 5 veces, comprobando los valores de ID 0 - 4 y luego rompiendo el bucle cuando se encuentre el gamepad). Así que, haz (o abre) un objeto, asígnale un sprite, y luego añade
      un <strong>evento de creación</strong> con lo siguiente:</p>
    <p class="dropspot"><img alt="Getting Gamepad ID Using DnD" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_3_1.png" /></p>
    <p class="code">gamepad_id = -1;<br> for (var i = 0; i &lt; 12; i += 1;)<br> {<br> if gamepad_is_connected(i)<br> {<br> gamepad_id = i;<br> gamepad_set_axis_deadzone(gamepad_id, 0.2);<br> break;<br> } <br> }
    </p>
    <p class="dropspot">Fíjate que en el código anterior ponemos el <strong> <a class="glossterm" data-glossterm="deadzone" href="#">zona muerta</a> </strong>para el gamepad. Esto se debe a que los sticks analógicos en diferentes marcas de gamepads tendrán diferente sensibilidad, y a veces
      pueden ser tan sensibles que si no estableces una zona muerta pueden causar movimientos no deseados en tus juegos. Así que establecemos la zona muerta a un valor como 0,2 para decirle a <span class="notranslate">GameMaker Studio 2</span> que ignore cualquier valor de stick de gamepad por debajo de ese valor <a class="glossterm" data-glossterm="absolute" href="#">absoluto</a>.</p>
    <p class="dropspot">Para añadir el movimiento real, necesitaremos un <strong>Evento de</strong> Paso <strong>, así que</strong> añádelo ahora y dale el siguiente DnD™ o GML:</p>
    <p class="dropspot"><img alt="Get Gamepad Input Using DnD" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_3_2.png" /></p>
    <p class="code">if gamepad_id &gt; -1<br> {<br> var _h = gamepad_axis_value(gamepad_id, gp_axislh);<br> var _v = gamepad_axis_value(gamepad_id, gp_axislv);<br> x += _h * 4;<br> y += _v * 4;<br> }</p>
    <p class="dropspot">Aquí estamos comprobando el movimiento horizontal o vertical del stick <em>izquierdo </em>. Las funciones de eje devuelven un valor entre -1 y 1, así que para el eje horizontal -1 es izquierda, 0 es no moverse y 1 es derecha, y para el eje vertical es -1 para
      para arriba, 0 para no moverse y 1 para abajo. Tenga en cuenta también que los valores están <em>entre </em>-1 y 1, por lo que -por ejemplo- el eje horizontal podría devolver un valor de 0,5, lo que significa que el stick está a medio camino entre la posición de &quot;reposo&quot; y totalmente empujado
      hacia la derecha. Por esta razón, multiplicamos el valor por 4 (en realidad puedes multiplicar por cualquier valor, dependiendo de la velocidad a la que quieras que se mueva la instancia) - significa que la velocidad de la instancia variará dependiendo de la cantidad de movimiento que se haya hecho en el eje del stick.
      se ha hecho en el eje del stick.</p>
    <p class="dropspot">Coloca una instancia de este objeto en una habitación y presiona el botón <strong>Play </strong><strong> <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png"></strong>y muévete con el stick izquierdo de tu gamepad conectado.
      gamepad conectado. Deberías ver algo así:</p>
    <p class="dropspot"><img alt="Animation Showing Gamepad Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_3_1.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Movimiento avanzado en 8 direcciones</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">En este último ejemplo, vamos a volver a revisar nuestro código de movimiento de 8 direcciones y abordar un problema que tiene, que es que el movimiento en diagonal es en realidad más rápido que el movimiento arriba/abajo/izquierda/derecha. Esto es simplemente porque cuando se mueve en diagonal, se está moviendo
      a lo largo de la hipotenusa de un triángulo rectángulo creado por los valores de movimiento x/y:</p>
    <p class="dropspot"><img alt="Image Showing Why Diagonal Movement Is Faster" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_4_1.png" /></p>
    <p class="dropspot">Para que quede más claro lo que ocurre, eliminemos todo el texto y los sprites y mostremos simplemente la misma línea de movimiento girada 45º para que sea horizontal:</p>
    <p class="dropspot"><img alt="Simplified Image SHowing Diaginal Movement Is Faster" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_4_2.png" /></p>
    <p class="dropspot">Como puedes ver, la diferencia es bastante obvia, y si la instancia se mueve más de 1 o 2 píxeles por paso, entonces se hace muy notorio que el movimiento diagonal es <em>mucho </em>más rápido. Entonces, ¿cómo limitamos esto? Hay varias maneras de hacerlo, pero vamos a
      de hacerlo, pero vamos a concentrarnos en una de ellas, porque introduce un par de funciones y conceptos que te serán útiles más adelante en tus juegos.</p>
    <p class="dropspot">Para ello, vamos a tener que almacenar los valores de entrada de las teclas pulsadas de forma independiente en<span class="glossextra">variables</span>, para luego comprobarlos y desplazarnos según
      la combinación de teclas que se han pulsado. Así que, para esto necesitarás un objeto con un sprite asignado, y tendrás que darle un <strong>Evento</strong> de Paso <strong>con</strong> el siguiente DnD™ <span class="notranslate">o GML</span>:</p>
    <p class="dropspot"><img alt="DnD Step Event Actions To Define Movement Variables" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_4_1.png" /></p>
    <p class="note"><strong>NOTA</strong>: Hemos dividido el DnD™ de arriba en dos columnas para que sea más fácil de visualizar, pero en el editor de DnD™ se colocará consecutivamente.</p>
    <p class="code">var _left = keyboard_check(vk_left);<br> var _right = keyboard_check(vk_right);<br> var _up = keyboard_check(vk_up);<br> var _down = keyboard_check(vk_down);<br> var _hspd = _right - _left;<br> var _vspd = _down - _up;</p>
    <p class="dropspot">Tendremos que añadir algo más de código para poder movernos realmente, pero antes vamos a explicar esto un poco. Queremos convertir izquierda/derecha/arriba/abajo en valores de velocidad horizontales y verticales equivalentes, así que para hacerlo estamos obteniendo el valor de cada tecla
      y luego hacemos algunas matemáticas básicas para obtener los valores de velocidad. Esto funciona porque si una tecla está siendo presionada entonces la acción o función de control devolverá &quot;1&quot;, y si no está siendo <em>presionada, </em>entonces la función devolverá
      0. Así que, si - por ejemplo - la derecha está siendo presionada, tienes &quot;1 - 0 = 1&quot; para el &quot; <span class="inline">_hspd</span>&quot;, y si la izquierda está siendo presionada tienes &quot;0 - 1 = -1&quot; para el &quot; <span class="inline">_hspd</span>&quot;
      (y si ambos son presionados entonces es &quot;1 - 1 = 0&quot;, por lo que la instancia no se moverá). Recuerde, en una sala de <span class="notranslate">GameMaker Studio 2</span>, para moverse a la derecha sumamos a la posición de <span class="inline">x </span>y para moverse a la izquierda restamos, por lo que este
      código nos dará un valor positivo o negativo que podemos sumar o restar para movernos horizontal o verticalmente dependiendo de la entrada del teclado.</p>
    <p class="dropspot">Ahora podemos añadir el código que realmente mueve la instancia, por lo que - todavía en el <strong>evento de paso</strong>, y después del código anterior - añadir esto:</p>
    <p class="dropspot"><img alt="DnD Step Event Actions To Move The Instance" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_4_2.png" /></p>
    <p class="code">if (_hspd != 0 | _vspd != 0)<br> {<br> var _spd = 4;<br> var _dir = point_direction(0, 0, _hspd, _yspd);<br> var _xadd = lengthdir_x(_spd, _dir);<br> var _yadd = lengthdir_y(_spd, _dir);<br> x = x + _xadd;<br> y
      = y + _yadd;<br> }</p>
    <p class="dropspot">El código anterior comprueba primero si una de las dos<span class="glossextra">expresiones</span> es verdadera, es decir, si las variables de velocidad horizontal o vertical no son 0. Obsérvese que la comprobación GML &quot;
      <span class="inline">if</span> &quot; utiliza el símbolo &quot; <span class="inline">||</span>&quot;. Esto significa &quot; <span class="inline">or</span>&quot; en programación, por lo que - en lenguaje llano - se está comprobando</p>
    <p class="code">si la variable _hspd no es igual a cero <strong>o </strong>si la variable _vspd no es igual a cero</p>
    <p class="dropspot">De este modo, se pueden encadenar varias expresiones en las comprobaciones &quot; <span class="inline">if</span>&quot;, y existen múltiples formas diferentes de evaluar esas expresiones (para más información, consulte la sección sobre Expresiones <strong>aquí</strong> ).</p>
    <p class="dropspot">La siguiente sección de código almacena un valor para la velocidad de movimiento real en una variable y luego obtiene una dirección usando los valores <span class="inline">_hspd </span>y <span class="inline">_vspd </span>, que pueden ser -1, 0 o 1. La función de dirección
      comprueba desde (0, 0) ya que no estamos utilizando coordenadas de la habitación, y en su lugar queremos que se evalúe como una dirección de 0° a 360° basada en los valores de las variables. El siguiente diagrama ilustra mejor lo que ocurre que intentar explicarlo con
      palabras:</p>
    <p class="dropspot"><img alt="Example Image Showing Direction Around (0,0) Origin" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_4_3.png" /></p>
    <p class="note"><strong>NOTA</strong>: La dirección en <span class="notranslate">GameMaker Studio 2</span> se calcula <strong>en sentido contrario a las agujas del reloj</strong>, por lo que 0° y 360° son a la derecha, 90° es arriba, 180° es a la derecha y 270° es abajo.</p>
    <p class="dropspot">Por último, utilizamos el <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_x.htm"><span class="inline">lengthdir_x()</span></a> y <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_y.htm"><span class="inline">lengthdir_y()</span></a> 
      para mover realmente la variable. Se trata de funciones <strong> <a class="glossterm" data-glossterm="vector" href="#">vector</a>  </strong>que toman una longitud (distancia) y una dirección y luego calculan la nueva posición en el eje dado basándose en estos valores
      (ver las descripciones de las funciones para una explicación más detallada).</p>
    <p class="dropspot">Es mucho para asimilar de una vez, y no te preocupes si no lo entiendes todo. Lo harás con el tiempo. Lo único que queda por hacer es añadir una instancia de este objeto a una habitación y pulsar el botón Play <strong> <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png"></strong>,
      y deberías obtener un movimiento suave como la seda en 8 direcciones sin ninguno de los problemas relacionados con el movimiento en diagonal:</p>
    <p class="dropspot"><img alt="Animation Showing Improved 8-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_4_4.gif" /></p>
  </div>
  <p> </p>
  <p>Con estos ejemplos -y los anteriores de dibujo- esperamos que hayas entendido lo suficiente como para empezar a hacer tus propios proyectos. La última página de esta Guía de inicio rápido contiene un resumen de algunas de las cosas que has aprendido, así como
    así como enlaces a materiales de aprendizaje adicionales.</p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Volver: <a href="../Content.htm">Index</a></div>
        <div style="float:right">Siguiente: <a href="Summary.htm">Resumen</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Todos los derechos reservados</span></h5>
  </div>
  <!-- KEYWORDS
Movement
Controls
Movement and Controls
Movement Examples
Controls Examples
-->
  <!-- TAGS
qs_movement_controls
-->

</body></html>